\chapter{Implementation and Test Instances}

\section{Test Instances}
The test instances for the MKP were kindly provided to us by the authors of~\cite{mkp:2019}.\\
There are in total 2100 test instances, organized in
five directories of increasing complexity:
\begin{itemize}
    \item SMALL
    \item FK\_1
    \item FK\_2
    \item FK\_3
    \item FK\_4
\end{itemize}
SMALL contains 180 instances, while FK\_1, FK\_2, FK\_3, FK\_4 contain 480 instances each.
The instances in the first three directories were already solved to the optimum.
Of those in the last two folders only a few were already solved: the unsolved
ones only had an upper and lower bound.
\newpage
\section{How to read an Instance}
Every instance was generated randomly by the authors of~\cite{mkp:2019}.
The name of each instance contains different information, in order to fastly understand the dimension of the problem represented.
The first integer represents the knapsacks number, while the second indicates then number of the items.
The last integer is used to differentiate the instances belonging to the same class.

%inseririre come leggere una stringa per capire di che problema si tratta

Our test instances are text files, in which are contained the data related to the knapsacks and their \textbf{capacity} and items with their \textbf{profit} and \textbf{weight}. An example of an instance's structure is shown below:

	\begin{flushleft} 
		$\begin{rcases*}
			3 \quad
		\end{rcases*} \rightarrow $ integer that indicates the value of $ \textit{\textbf{m} (number of knapsacks).}$
	\end{flushleft}
	\begin{flushleft}
		$\begin{rcases*}
			7 \quad
		\end{rcases*} \rightarrow $ integer that indicates the value of $ \textit{\textbf{n} (number of items).}$
	\end{flushleft}

	\begin{flushleft}
		$\begin{rcases*}
			908 \quad
			\\834 
			\\675 
		\end{rcases*} \rightarrow $ integers that indicate the \textbf{capacity}  $ c_{i} $  of the knapsack i with \space $ i=1,\:\dots\:,m. $
	\end{flushleft}
	\begin{flushleft}
		$\begin{rcases*}
			264	\quad 430 \quad
			\\606 \quad	945
			\\268 \quad	409
			\\619 \quad	591
			\\958 \quad	839
			\\972 \quad	818
			\\723 \quad	71
		\end{rcases*} \rightarrow $ 
		$\begin{rcases*}
			{\begin{tabular}{@{}l@{}}
				First column shows the \textbf{weight} $ w_{i}. $ \\
				Second column shows the \textbf{profit} $ p_{i} $.
			\end{tabular}} 
		\end{rcases*} \rightarrow \space$ $ i=1,\:\dots\:,n. $
	\end{flushleft}

For most of the instances with the exact solution calculated by the authors of the paper, we were able to
find too the exact using an exact GUROBI solver, with the following configuration:

\begin{itemize}
    \item Presolve = 2 (aggressive presolve)
    \item Time limit = 1 hour
    \item Threads = 12
    \item MIPGap = \num{1e-12}
\end{itemize}

The code can be found at \url{https://github.com/Golino98/EsattoMKP}

To simplify the testing of the changes to the kernel search algorithm,
we only considered 40 instances: 6 solved to the optimum for each directory,
plus 10 that we weren't able to solve to the best.

Tables~\ref{tab:exact_opt} and~\ref{tab:exact_noopt} represent,
respectively, the optimum values of the 30 instances solved to
the optimum, and the upper and lower bound for the 10
that couldn't be solved.

\input{tables/exact_opt.tex}
\input{tables/exact_noopt.tex}

\section{Performance of the exact algorithm}


\section{Performance of the default kernel search}


\section{Performance of random variable sorting}
